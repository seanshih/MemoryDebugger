CS391 Assignment 2
180006613 Hsi-Hung Shih

------------
a.	Write up covers how to integrate the memory debugger.  Also document what configuration options are available to customize the debugging. (what if any code/project changes are required to add it to an existing project) (3 pts)

To integrate, it only requires at most three lines. Do the following steps,
1. include "new_override.h"
2. At the beginning of main, create a LeakReporter object.
   It takes a c-style string as output file path.

    e.g. LeakReporter reporter("leaks.log");

3. To set the detection mode, one could use

    LeakReporter::SetDetectMode(LeakReporter::BoundaryDetectMode::DETECT_OVERFLOW);

    BEFORE the creation of LeakReporter. 

NOTE:
   This object will report memory leak as well as allocation info when it is destructed. 

    As for the detection mode settings, it is considered an error if this is called 
    after the creation any LeakReporter object. 
    
    Detection mode can be set to
    DETECT_UNDERFLOW, DETECT_OVERFLOW, DETECT_NO_ACCESS_DETECTION

    When DETECT_NO_ACCESS_DETECTION, the memory usage is greatly reduced.
    However, this will disable the read/write access violation and underflow/overflow detection.

----------
b.	Write up covers what information the memory debugger logs in the event of a leak and what additional information is available in the event of a heap bug.  (3 pts)

If the program runs and finishes without crashing, the LeakReporter will
report memory leaks when there are any undeleted memory. It will report the
following information

1. File, line number and function name when the undeleted allocation occurs
2. A statistics report that tells the user how many memory leaks there are for
every lines that have leaks.

Besides leak information, it will always report allocation information that
contains

1. A statistics report about how many allocations for all lines of code that
call new. 

2. A "hot chart" will be provided on the right side for each line in
the form of "star line". By comparing the length of the line, The user can 
easily identify if there are lines that
are memory allocation intensive.


-------------
c.	Write up covers what design decision you made when implementing the project.  Where did you put no mans lands and why?  Did you use a linked list to track the allocations or a something else?  How did you replace new?  I want to understand the choices you made when implementing the project. (3 pts)

I override the 8 new functions instead of using define. I made this decision
because it can also detect memory allocation inside STL containers. Also I
would like to learn how to detect the name and line number of the calling
function without using macro.

I put no mans lands right after memory allocation. This way it could detect
buffer overflow. It is also set for any deleted memory, so that one could
detect access after deletion.

To track allocation, I use unordered_map. Although it is relatively
inefficient, it seems acceptable because the major purpose of the system is to
detect memory bug, and it will be disabled in the release build so it won't
affect the actual performance. 

I replace new simply by overriding all 8 of them. Since most of their contents 
are the same, I wrote a helper function for allocation and deallocation, and
all new and delete just delegate their reponsibilities to these two functions.

------------
Extra Credit

1. Allocation statistics to find heap hot spots (with star line)
    - no need to setup anything, it will show up in leaks.log
    - The implementation is just keeping all deleted address information. As a
      result, the program could summarize all allocations at the end.

2. Underflow detection
   - to test, use the following line to set to underflow mode

        LeakReporter::SetDetectMode(LeakReporter::BoundaryDetectMode::DETECT_UNDERFLOW);

    then you can change the scenario to 13 and 14 to test underflow read and
    write access respectively.

    Also, you could use other scenario to test underflow detection. It should
    work with most of the scenarios, except the detecting overflow ones.

   - The implementation is switching the side of the "no mans land" when using
     VirtualAlloc, so it can detect access violation before the allocated
     address.



